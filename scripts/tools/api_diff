#!/bin/bash
#
# Copyright 2016-present the Material Components for iOS authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Writes a CHANGELOG.md-ready API diff for the latest release to stdout.

cmd=$(basename "${BASH_SOURCE[0]}")
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"; pushd $DIR >> /dev/null
MDC_ROOT="$(git rev-parse --show-toplevel | tail -n1)"; popd >> /dev/null
cd $MDC_ROOT

validate_commit() {
  git cat-file -t $1 >> /dev/null 2> /dev/null || { echo "$1 is not a valid commit."; exit 1; }
}

clean_clones() {
  if [ ! -z "$OLD_ROOT_PATH" ]; then
    rm -rf "$OLD_ROOT_PATH"
  fi
  if [ ! -z "$NEW_ROOT_PATH" ]; then
    rm -rf "$NEW_ROOT_PATH"
  fi
}

if [ ! $(git rev-parse --verify release-candidate 2> /dev/null) ]; then
  echo "Please cut a release first by running scripts/release/cut."
  exit 1
fi

# Verify commits
old_commit=$(git rev-list -n 1 origin/stable)
new_commit=$(git rev-list -n 1 release-candidate)

if [[ -z "$old_commit" || -z "$new_commit" ]]; then
  echo "Unable to get commit shas."
  exit 1
fi

validate_commit $old_commit
validate_commit $new_commit

# Create temp directories for old commit and new commit
# Compute directories relative to the script's known location in scripts/
SCRIPTS_PATH="$MDC_ROOT/scripts"

TMP_PATH=$(mktemp -d)
trap clean_clones EXIT
OLD_ROOT_PATH="$TMP_PATH/old"
NEW_ROOT_PATH="$TMP_PATH/new"
"$SCRIPTS_PATH/temporary_clone_at_ref" "$OLD_ROOT_PATH" $old_commit
"$SCRIPTS_PATH/temporary_clone_at_ref" "$NEW_ROOT_PATH" $new_commit

# Find command in all component src directories and grab search path for "Material$component.h"
old_header_search_paths=""
new_header_search_paths=""
for d in $NEW_ROOT_PATH/components/*/src; do
  folder=$(dirname $d)
  component=$(basename $folder)
  old_header_search_paths="$old_header_search_paths --oldargs -I$OLD_ROOT_PATH/components/$component/src/ "
  new_header_search_paths="$new_header_search_paths --newargs -I$NEW_ROOT_PATH/components/$component/src/ "
done

if [ ! -f "$SCRIPTS_PATH/external/material-motion-apidiff/src/pathapidiff" ]; then
  git submodule update --init --recursive
fi

ALL_CHANGELOG_PATH="$TMP_PATH/changelog"
ALL_ERROR_LOG_PATH="$TMP_PATH/errlog"

echo "Changelog: $ALL_CHANGELOG_PATH"
echo "Errors: $ALL_ERROR_LOG_PATH"

# Run new pathdiff script on each umbrella header in array
for d in $NEW_ROOT_PATH/components/*/src; do
  folder=$(dirname $d)
  component=$(basename $folder)

  echo -n "Diffing $component..."

  if [ ! -d "$OLD_ROOT_PATH/components/$component/src" ]; then
    echo >> $ALL_CHANGELOG_PATH
    echo "### $component" >> $ALL_CHANGELOG_PATH
    echo >> $ALL_CHANGELOG_PATH
    echo "**New component.**" >> $ALL_CHANGELOG_PATH

    echo "New!"
    continue
  fi

  CHANGES_PATH="$TMP_PATH/${component}changes"
  ERROR_PATH="$TMP_PATH/${component}errlog"

  "$SCRIPTS_PATH/external/material-motion-apidiff/src/pathapidiff" \
     "$OLD_ROOT_PATH" "$NEW_ROOT_PATH" objc "/components/$component/src/Material$component.h" \
     >> "$CHANGES_PATH" \
     2>> "$ERROR_PATH"

  if [ -s "$CHANGES_PATH" ]; then
    echo >> $ALL_CHANGELOG_PATH
    echo "### $component" >> $ALL_CHANGELOG_PATH
    cat "$CHANGES_PATH" >> $ALL_CHANGELOG_PATH

    echo -n " Changes detected."
  fi

  if [ -s "$ERROR_PATH" ]; then
    echo "### $component" >> "$ALL_ERROR_LOG_PATH"
    cat "$ERROR_PATH" >> "$ALL_ERROR_LOG_PATH"

    echo -n " Errors detected."
  fi

  echo
done
